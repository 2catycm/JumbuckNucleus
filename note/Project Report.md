# 基于 RISC-V 架构与Rust语言的16KiB页面操作系统

# ——操作系统 Project 报告

[TOC]

## 项目简介

### 项目协作

| 姓名   | 学号     | 负责内容                                                     |
| ------ | -------- | ------------------------------------------------------------ |
| 叶璨铭 | 12011404 | 阅读RISCV手册，进行QEMU与地址空间设计。用Rust实现并测试物理页分配、进程切换算法。实验测定16KiB方案的优劣。 |
| 邓值仁 | 12012029 | 掌握Rust语言。深入理解并文档化rCore，深度优化 rCore 设计，使得每个部分都比较稳定可靠、简单清晰、符合rust规范。 |

---

### 为什么页面大小选择为16KiB，而不是传统甚至是默认的4KiB？

内存的容量近年来不断发展，容量较大，然而分页方案的页面大小，仍然是上个世纪1960年代就使用的4KiB大小。[^8]那么，基于16KiB页面的OS有什么优势呢？

#### 从缓存（按需分页）的角度来看

​	从按需分页(Demand paging)的角度来看，内存是磁盘的缓存。所谓分页，就是缓存中的分 block ， 也就是一个传输单位。同一个block或者page的地址(访问需求), 由于访问的内容处于硬件上的同一个传输单位，因此只需第一次访问遍将内容缓存，加速大量的后续访问。从上面的原理描述可以看出，block越大，理论上block越大，Miss Rate便越低。极端情况下

<img src="Project Report.assets\image-20220729190213362.png" alt="image-20220729190213362" style="zoom:33%;" />

当然，Block太大也会出现以下的问题:

- Miss Penalty 增大。即 Page Replacement 完成所需时间增加。

#### 从虚拟化的角度来看

上面我们考虑了“物理内存不够，需要磁盘来补充”的早期分页想法之一，然而如今物理内存未必小于虚拟内存。另一个分页的想法来自于 虚拟化为不同进程带来的保护。那么，我们应当注意到，不同进程的地址空间不同。

- 假设进程A, B, C, D分别连续访问了4KiB个字节s
  - 由于四个进程的地址空间不同，他们分别申请了四个不同的16KiB页面而无法互相利用。
  - 如果进程之间频繁切换而内存不够大（比如只有16KiB左右）的话，就会出现页面的频繁替换。

- 假设进程A连续访问了16KiB个字节，
  - 我们使用16KiB的分页方案，只有一次compulsory miss。
  - 这一次就非常合理地利用了内存空间。

可见，使用多大的页面，和各种进程平均需要访问的内容多少有关系。

另一方面，考虑进程间的通信，进程的内存共享是最简单的方式之一。

- 而内存共享的单位是页。
- 如果页的大小足够，那么通信之间发生的争端(resolution)就会少很多。[^8]

#### 从分段的角度来看

过大的block会导致内存碎片化的加剧，但是另一方面也减少了内存碎片化。

从外部碎片化的角度来看，

- 分页机制本身作为一种**定长的**分段方法（以前的分段方法是根据程序的code\stack\data\bss这样分的），本身就是为了避免外部碎片化。
  - 定长的页面大小让连续内存分配的算法更加容易设计，因此有更好的性能保证。
- 另一方面，更大的页让内存的可申请尺度变大，
  - 换句话说，碎片的最小大小是一个页，所以不存在比一个页还要小的外部碎片，也就不会出现环节了外部碎片化。

从内部碎片化的角度来看，

- 大的页面导致了内部碎片化。用户可能只申请了一两个字节，就获得了整个物理页面。
- 这种情况叫做系统颠簸(Trashing)。[^8]

然而，Weisberg 和 Wiseman 认为，**随着内存容量的急剧增大，trashing的问题并不是什么问题**。如果用户需要很大的内存，那么大的页面很合适，如果用户所需内存很小，最多也就浪费一个页面的大小。相比于16GiB的内存，一个进程至多浪费4KiB显得根本不是问题，所以改成16KiB也不会造成什么影响。[^8]

#### 从硬件接口的角度来看

传统的硬盘设备的一个 Sector 往往就是4KiB，也就是说磁盘一次只能支持 4KiB 大小的传输，这就限制了操作系统的设计也将页面大小设计为4KiB。

然而，近年来，硬盘设备技术发展，16KiB的传输大小并不是什么难事。

#### 从内存管理开销(overhead)的角度来看

- 大的页面，减少了相同大小内存下页面的数量，也就降低了PTE在页表中的数量，进而减少单个页表的大小[^8]也减少了多级页表的页表总数量
- 然而实际上，由于MMU硬件的限制，比如RV64的Sv39方案，
  - MMU硬件只认PPN来寻找页表。
  - 换句话说，一个页表必须占据一个页的大小。
  - 因此无法有效发挥这一优势。
- 虽然MMU有限制，第二个优点：降低了多级页表的总数量，还是有所体现的。
  - ![image-20220801001934272](Project Report.assets\image-20220801001934272.png)
  - 如图为Sv39分页方案，我们称PPN[2:0]对应的页表为二级、一级、零级页表。
  - 一个巨页为2MiB, 吉页为1GiB。
  - 若**连续申请**T个字节，至多需要$1+\lceil T/2MiB \rceil + \lceil T/1GiB\rceil$个页表（二级页表、一级页表、零级页表）[^2]
  - 如果改为我们的16KiB页面方案（9,9,9,14）
    - 一个巨页为8MiB, 吉页为4GiB。
    - 那么至多需要$1+\lceil T/8MiB\rceil +\lceil T/4GiB\rceil$个页表，页表的数量少了大约4倍。

#### 从TLB的角度来看

Weisberg 和 Wiseman 认为， 以上因素都有道理，但是之所以16KiB应当是最优选择，最重要的因素是比起4KiB，16KiB可以显著提高TLB的命中率。[^8]

不妨设内存总大小一定、TLB能存的PTE大小一定、页表能存储的页表项一样多。

假设 TLB能存储256项PTE，Page Size是4KiB。

- 那么TLB能管辖的内存范围是1MiB，如果有连续1MiB的多次访问，TLB在访问过一次后就能对这1MiB范围的所有虚拟地址命中。
- 而如果增大Page Size为16KiB，管辖范围就能提高4倍。
- 对于相同的地址访问来说，TLB 的 miss rate就可以大幅降低。
- 当然，使用巨页也可以增加管辖范围，不过仍然有4倍的关系，而且16KiB优势更为显著。

几年来，硬件设备的速度提升、内存的急剧增大，使得仍为4KiB的页面大小降低了TLB相对于整个内存的覆盖率，因此，提高Page的大小是合理而有必要的。[^8]

根据 Weisberg 和 Wiseman 的实验结果，16KiB的分页方案比起4KiB降低了1/3的TLB miss数，增加了2/3的内存空间使用，对于如今大的内存硬件而言，是值得的。[^8]



---


### 为什么选择用Rust语言做Project？

本次 Project 我们没有使用Lab中的C语言代码，而是根据rCore的指导重新构建出一个操作系统。Rust是一门赋予每个人构建可靠且高效软件能力的语言，具有**高性能、可靠性、生产力**这三大优势。[^7]本次我们使用Rust开发操作系统Project的过程中，充分运用了这三大优势。

#### 生产力。

1. 可拔插的语言特性。

   比起C语言和C++写操作系统没有任何标准库，Rust语言在设计时便考虑了裸机环境、嵌入式设备下没有标准库的问题。使得我们在编写操作系统的时候，仍然可以使用core核心库。

   此外，只要在具体平台上编写相应的语言特性，便可以逐步恢复标准库的功能。

2. 优质的包管理器。

   比如，**riscv库**。

   相比用C语言做这次Project

3. 出色的文档

   比如，**cargo doc**

   相比用C语言做这次Project

4. 清晰的错误提示

   比如，

   相比用C语言做这次Project

#### 可靠性。

Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。[^7]

举个例子，**Frame Tracker**的设计。

#### 高性能。

Rust 和C++语言一样，提供了“零开销”的抽象。我们用Rust写操作系统，不仅不会比C语言慢，还可能因为更加清晰的类型系统和所有权机制使得导致变慢的操作在编译时就消除，从而获得更好的内存利用率。

---



## 应用程序与基本执行环境

### 16KiB下的QEMU



### Rust 执行环境

#### 实现 致命错误处理器，蓝屏机制

#### 实现log输出

- 方便debug调试。

#### 实现条件编译（Makefile+rust feature）

- 允许快速选择4KiB还是16KiB

#### Qemu远程gdb

## 16KiB下内存布局与地址空间的设计

### 地址转换模式

### 物理内存分配算法（堆与物理页帧）

#### best\first\worst

#### buddy system

## 实现多道程序、分时多任务与进程。

### fork() exec() 系统调用, 用户shell

### initproc 进程

### elf 加载

## 16KiB 相比 4KiB 性能测试

假说演绎法。

![Snipaste_2022-07-31_23-43-12](Project Report.assets\Snipaste_2022-07-31_23-43-12.png)

![Snipaste_2022-07-31_23-44-06](Project Report.assets\Snipaste_2022-07-31_23-44-06.png)

# 参考文献

[^1]: R. H. Arpaci-Dusseau and A. C. Arpaci-Dusseau, *Operating systems: Three easy pieces*, 1.00. Arpaci-Dusseau Books, 2018.
[^2]: “rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档.” http://rcore-os.cn/rCore-Tutorial-Book-v3/index.html (accessed Jul. 27, 2022).
[^3]: “rCore-Tutorial V3 实验指导书” http://rcore-os.cn/rCore-Tutorial-deploy/ (accessed Jul. 21, 2022).
[^4]: “Rust 语言圣经 - Rust语言圣经(Rust Course).” https://course.rs/about-book.html (accessed Jul. 21, 2022).
[^5]: “uCore-Tutorial-Guide-2022S 0.1 文档.” https://learningos.github.io/uCore-Tutorial-Guide-2022S/index.html (accessed Jul. 27, 2022).
[^6]: "RISCV 中文手册." https://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf (accessed Jul. 21, 2022).
[^7]: Rust 程序设计语言.” https://www.rust-lang.org/zh-CN/ (accessed Jul. 29, 2022).

[^8]: P. Weisberg and Y. Wiseman, “Virtual Memory Systems Should use Larger Pages,” Aug. 2015, pp. 1–4. doi: [10.14257/astl.2015.106.01](https://doi.org/10.14257/astl.2015.106.01).

