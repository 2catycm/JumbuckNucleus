# 第四章：地址空间

## 引言

物理内存是资源->虚拟化资源。好处

- 允许应用与内核 动态 获得内存
  - 应用应当动态获得空间，结束的时候可以供别的应用使用。
  - 具体实现主要集中在 `os/src/mm/heap_allocator.rs` 中
- 编译器可以简单设置地址空间，放置符号位置。
  - 应用不需要在构建时了解物理内存布局，体现了透明性。
  - 具体而言，主要就是把 `linker.ld` 中应用程序的起始地址都改为 `0x10000` ，这是假定我们操作系统能够通过分页机制把不同应用的相同虚地址映射到不同的物理地址中。
- 应用之间、和内核之间的隔离
  - 访存行为的保护措施。即使是U特权级，对内存也必须有限制。

分页机制的10个问题与解答：

- 硬件中物理内存的范围是什么？
  - Qemu默认范围是8MiB，从0x80000000到0x80800000。 
  - 从kernel结束的位置开始，可以用于物理页帧的管理。
  - 建立页表前，首先要知道物理内存的范围，并且以物理页帧为单位分配和回收内存。
  - 操作系统内核能够以物理页帧为单位分配和回收物理内存，具体实现主要集中在 `os/src/mm/frame_allocator.rs` 中；也能在虚拟内存中以各种粒度大小来动态分配内存资源，具体实现主要集中在 `os/src/mm/heap_allocator.rs` 中。
  - 虚拟地址、物理地址、虚拟页号、物理页号之间进行各种转换，在 `os/src/mm/address.rs` 中实现了各种转换函数。
- 哪些物理内存空间需要建立页映射关系？
- 如何建立页表使能分页机制？
  - 主要涉及到页表项的数据结构表示，以及多级页表的起始物理页帧位置和整个所占用的物理页帧的记录。具体实现主要集中在 `os/src/mm/page_table.rs` 中。
- 如何确保 OS 能够在分页机制使能前后的不同时间段中都能正常寻址和执行代码？
  - 内核中也将基于虚地址进行虚存访问。所以在给应用添加虚拟地址空间前，内核自己也会建立一个页表，把整块物理内存通过简单的恒等映射（即虚拟地址映射到对等的物理地址）映射到内核虚拟地址空间中。
  - 
- 页目录表（一级）的起始地址设置在哪里？
  - 
- 二级/三级等页表的起始地址设置在哪里，需要多大空间？
- 如何设置页目录表项/页表项的内容？
- 如果要让每个任务有自己的地址空间，那每个任务是否要有自己的页表？
  - 需要。每个进程的虚拟地址空间由操作系统设定。
  - 虚拟地址空间需要有一个数据结构管理起来，这就是 `MemorySet` ，即地址空间这个抽象概念所对应的具象体现。
- 代表应用程序的任务和操作系统需要有各自的页表吗？
  - 需要对来自用户态和内核态的异常/中断分别进行处理
- 在有了页表之后，任务和操作系统之间应该如何传递数据？
  - 知道用户态应用的虚地址对应的物理地址后，转换成对应的内核态的虚地址，才能访问应用地址空间中的数据。如果访问应用地址空间中的数据跨了多个页，还需要注意处理地址的边界条件。

## 内核中 Rust 动态内存分配

一块大内存空间作为初始的“堆”。->提供在堆上分配和释放内存的函数接口。->提供空闲空间管理的连续内存分配算法。->提供建立在堆上的数据结构和操作。

为什么要有动态分配？

- 编程的时候并不知道待处理的文件大小，只能根据经验将缓冲区的大小设置为某一固定常数。
- 数组同理。
- 可以灵活控制生命周期。

动态分配的难点？

- 连续内存分配问题
  - 给进程一块不小于指定大小的连续物理内存区域。
  - 进程会结束。所以需要维护空闲分区列表。
  - 查找开销、合并开销、合并后维护列表开销
  - 最先匹配（第一个遇到的可以用的），
    - 最先匹配外碎片有，所有扫描到后面的大块慢。
  - 最佳匹配（比我大的最小的）
    - 空闲分区从小往大排序，扫描空闲分区列表。
    - 释放时合并临近分区。
  - 最差匹配
    - 适合中等大小的分配。
  - 伙伴系统
    - 
- malloc，通过brk系统调用像内核申请增大堆。
- 会产生内存空间的浪费，即存在无法被应用使用的空闲内存碎片。

内存碎片

- 内碎片：已被分配出去（属于某个在运行的应用）内存区域，占有这些区域的应用并不使用这块区域，操作系统也无法利用这块区域。
- 外碎片：还没被分配出去（不属于任何在运行的应用）内存空闲区域，**由于太小**而无法分配给提出申请内存空间的应用。

rust数据结构

- box = unique_ptr
- Rc = share_ptr
- RefCell 是动态的借用检查
- Arc<Mutex<T>>可以把全局变量多线程安全，而且内部可变。

alloc crate

- 两个接口中都有一个 `alloc::alloc::Layout` 类型的参数， 它指出了分配的需求，分为两部分，分别是所需空间的大小 `size` ，以及返回地址的对齐要求 `align` 。这个对齐要求必须是一个 2 的幂次，单位为字节数，限制返回的地址必须是 `align` 的倍数。
- 调用伙伴系统来完成堆分配
- 申请堆。
  - rust全局静态变量一个数组-》bss段的一个区域。占用KERNEL_HEAP_SIZE个8B
  - 通过 `as_ref` 和 `as_ptr` 方法可以分别看到它们指向的数据的位置，能够确认它们的确在位于 `.bss` 段的堆上。
- 

## 地址空间



## 管理Sv39多级页表

物理页帧的管理

- 将剩下的空闲内存以单个物理页帧为单位管理起来，当需要存放应用数据或扩展应用的多级页表时分配空闲的物理页帧，并在应用出错或退出的时候回收应用占有的所有物理页帧。

- 这一步当然也可以用buddy system，是对物理页号的管理
- 也可以用stack 管理，把空闲页面组织为stack

- 这里我们使用 `UPSafeCell<T>` 来包裹栈式物理页帧分配器。每次对该分配器进行操作之前，我们都需要先通过 `FRAME_ALLOCATOR.exclusive_access()` 拿到分配器的可变借用。
- ekernel地址和memory_end地址转换为物理页号。
- 这里借用了 RAII 的思想，将一个物理页帧的生命周期绑定到一个 `FrameTracker` 变量上，当一个 `FrameTracker` 被创建的时候，我们需要从 `FRAME_ALLOCATOR` 中分配一个物理页帧，如果移动到向量当中，声明周期就会延长。

多级页表管理

- Sv39的叶子节点保存512个PTE，一共4KiB。一个非页节点保存512个指向下级节点的指针，也是PTE。节点是一个线性表。
- V=1时，硬件不会触发page fault，同时也认为是有效的。V=1且RWX不全为0，MMU就会完成地址翻译。除了一开始手动的大页，rcore没有用大页。
- 



## 内核与应用的地址空间

